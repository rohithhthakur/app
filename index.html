import groovy.json.JsonSlurper

def DEPLOY_FOLDER_PATH = "DA_Jobs/Prod-Deploy-Jobs/crn-virtuoso/model-deployment-pipelines/"

properties([
    parameters([
        string(name: 'ModelName', defaultValue: 'All', description: 'Specific model to build, leave empty to build all.'),
        string(name: 'Version', defaultValue: 'All', description: 'Specific version to build, leave empty to build all versions.')
    ])
])

def models = []  // Declare models at a global scope to be accessible throughout the pipeline

node('aws-da-agents') {
    checkout scm

    // Stage to get the list of models based on directories or parameters
    stage("Setup & Initialization") {
        dir('models') {
            def files = findFiles()
            models = files.findAll { it.directory }.collect { it.name }
            if (params.ModelName != 'All' && params.ModelName.trim()) {
                models = models.findAll { it == params.ModelName }
                if (models.isEmpty()) {
                    error "Specified model '${params.ModelName}' not found. Please check the model name."
                }
            }
            println("Models to be processed: " + models.toString())
        }
    }

    // Stage to build or deploy models in parallel
    stage("Model Deployment") {
        def modelJobs = [:]
        models.each { model ->
            modelJobs[model] = {
                deployModel(model)
            }
        }
        parallel modelJobs
    }

    // Stage to send Slack notifications
    stage("Notification") {
        notifySlack(modelJobs)
    }
}

// Function to deploy a model and its versions
def deployModel(String model) {
    def model_config = readJSON(file: "models/${model}/configuration.json")
    def versions = model_config.versions
    if (params.Version != 'All' && params.Version.trim()) {
        versions = versions.findAll { it.version == params.Version }
        if (versions.isEmpty()) {
            error "Specified version '${params.Version}' not found in model '${model}'. Please check the version."
        }
    }
    versions.each { version ->
        deployVersion(model, version)
    }
}

// Function to deploy
// Function to deploy a specific version of a model
def deployVersion(String model, Map version) {
    def branch = "releases%2Frelease-${version.version.replace('/', '%2F')}"
    if (model == "allm3_challenger") {
        branch = "releases%2Fchallenger%2Frelease-${version.version}"
    } else if (version.version.contains("allm4") && model == "allm3_spark") {
        branch = "releases%2F" + version.version.replace('/', '%2F')
    } else if (model == "ccrm-dagger-utils") {
        branch = "master"
    }
    def job = "${DEPLOY_FOLDER_PATH}${model_config.deploy_pipeline}/${branch}"
    try {
        build job: job
        println("Successfully deployed ${model} version ${version.version}")
    } catch(Exception e) {
        println("Failed to deploy ${model} version ${version.version}")
        throw e
    }
}

// Function to send notifications via Slack
def notifySlack(Map modelJobs) {
    withCredentials([string(credentialsId: 'slack_token', variable: 'token')]) {
        def message = new StringBuilder("Deployment summary:\n")
        modelJobs.each { key, value ->
            message.append("${key}: ${value.result == null ? 'SUCCESS' : 'FAILURE'}\n")
        }
        slackSend(
            message: message.toString(),
            channel: 'teamcore',
            color: (modelJobs.any { it.value.result == 'FAILURE' } ? '#ff9494' : '#36a64f'),
            teamDomain: 'fstech-nisone',
            token: token
        )
    }
}
