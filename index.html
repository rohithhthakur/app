Sure, I'll provide a detailed example to help you understand how `subprocess.Popen` works and why capturing both `stdout` and `stderr` is important to prevent hanging. Let's use a simple command that lists files in the current directory (`ls` on Unix-like systems or `dir` on Windows) as an example.

### Problematic Code Example

Here's an example of code that can potentially hang if the command generates a lot of output:

```python
import subprocess

# Command to list files in the current directory
command = "ls"  # Use "dir" on Windows

# This snippet captures only stderr and not stdout
result = subprocess.Popen(command, stderr=subprocess.PIPE, shell=True)
result.wait()
ret_code = result.returncode
if ret_code != 0:
    raise Exception("Command failed with return code {}".format(ret_code))
else:
    print("Command succeeded")
```

### Explanation of the Problem

1. **Creating the Subprocess**:
   ```python
   result = subprocess.Popen(command, stderr=subprocess.PIPE, shell=True)
   ```
   - `subprocess.Popen` creates a new subprocess to run the command.
   - `stderr=subprocess.PIPE` captures the standard error output, but `stdout` is not captured and goes to the terminal by default.

2. **Waiting for the Subprocess**:
   ```python
   result.wait()
   ```
   - `result.wait()` waits for the subprocess to complete. However, if the subprocess generates a lot of output on `stdout`, the buffer can fill up and cause the subprocess to hang.

### Corrected Code Example

Here's the corrected code that captures both `stdout` and `stderr` to prevent hanging:

```python
import subprocess

# Command to list files in the current directory
command = "ls"  # Use "dir" on Windows

# This snippet captures both stdout and stderr
result = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
stdout, stderr = result.communicate()
ret_code = result.returncode
if ret_code != 0:
    raise Exception("Command failed with return code {}\nError: {}".format(ret_code, stderr.decode()))
else:
    print("Command succeeded\nOutput:\n{}".format(stdout.decode()))
```

### Explanation of the Corrected Code

1. **Creating the Subprocess**:
   ```python
   result = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
   ```
   - This line creates a subprocess and captures both `stdout` and `stderr` using `subprocess.PIPE`.

2. **Communicating with the Subprocess**:
   ```python
   stdout, stderr = result.communicate()
   ```
   - `result.communicate()` reads the output and error streams. This method ensures that the buffers are managed correctly and prevents the subprocess from hanging.

3. **Getting the Return Code and Handling Output**:
   ```python
   ret_code = result.returncode
   if ret_code != 0:
       raise Exception("Command failed with return code {}\nError: {}".format(ret_code, stderr.decode()))
   else:
       print("Command succeeded\nOutput:\n{}".format(stdout.decode()))
   ```
   - `ret_code = result.returncode` retrieves the return code of the subprocess.
   - If the return code is non-zero, an exception is raised with the captured error message.
   - If the command succeeds, the standard output is printed.

### Running the Examples

To run these examples:

1. Save the code snippets to a `.py` file (e.g., `example.py`).
2. Open a terminal or command prompt.
3. Navigate to the directory where the file is saved.
4. Run the script using Python:
   ```sh
   python example.py
   ```

If you run the problematic code and the directory has many files, you might see the script hang. Running the corrected code should complete successfully and print the list of files or an error message if something goes wrong.