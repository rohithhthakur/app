Sure, let's go through the Groovy script line by line:

1. `import groovy.json.JsonBuilder`: Importing the JsonBuilder class from the Groovy JSON library. This class is used to build JSON data structures.

2. `import groovy.json.JsonSlurper`: Importing the JsonSlurper class from the Groovy JSON library. This class is used to parse JSON strings or files into Groovy data structures.

3. `import org.json.simple.JSONObject`: Importing the JSONObject class from the JSON.simple library. This class is used to represent JSON objects.

4. `import java.util.UUID`: Importing the UUID class from the Java utility library. This class is used to generate universally unique identifiers.

5. `def DEPLOY_FOLDER_PATH = "DA_Jobs/Prod-Deploy-Jobs/crn-virtuoso/model-deployment-pipelines/"`: Defining a variable `DEPLOY_FOLDER_PATH` with the path to the deployment pipelines.

6. `properties([...])`: Defining properties for the Jenkins job. In this case, defining parameters for the job, including `ModelName` and `Version`.

7. `node('aws-da-agents') { ... }`: Defining a Jenkins node where the job will be executed. In this case, the job will run on nodes labeled with 'aws-da-agents'.

8. `checkout scm`: Checking out the source code from the version control system (e.g., Git) using the Jenkins SCM plugin.

9. `def models = []`: Initializing an empty list called `models` to store information about models found in the `models` directory.

10. `def failed = []`: Initializing an empty list called `failed` to store information about failed deployments.

11. `stage("Get Models") { ... }`: Defining a stage named "Get Models" to retrieve information about available models.

12. `dir('models') { ... }`: Navigating to the 'models' directory within the workspace.

13. `def files = findFiles()`: Using the `findFiles()` function to find files and directories in the current directory.

14. `files.each { f -> ... }`: Iterating over each file or directory found.

15. `if (f.directory) { ... }`: Checking if the current item is a directory.

16. `try { ... } catch (Exception e) { ... }`: Using a try-catch block to handle exceptions when reading the configuration JSON file for each model.

17. `println("Model folders: " + models.collect { it.name })`: Printing the names of the model folders found.

18. `stage("Deploy Models") { ... }`: Defining a stage named "Deploy Models" to deploy the models.

19. `def deployStages = [:]`: Initializing an empty map called `deployStages` to store deployment stages for each model.

20. `models.each { model -> ... }`: Iterating over each model found.

21. `deployStages["Deploy ${model.name}"] = { ... }`: Adding a deployment stage for the current model to the `deployStages` map.

22. `def versionStages = [:]`: Initializing an empty map called `versionStages` to store deployment stages for each version of the current model.

23. `model.config.versions.each { version -> ... }`: Iterating over each version of the current model.

24. `versionStages["${model.name} - Version ${version.version}"] = { ... }`: Adding a deployment stage for the current version to the `versionStages` map.

25. `parallel versionStages`: Running all version deployment stages in parallel.

26. `parallel deployStages`: Running all model deployment stages in parallel.

27. `stage("Alert devs of available PRs") { ... }`: Defining a stage named "Alert devs of available PRs" to notify developers of the deployment status.

28. `def send_slack(failed) { ... }`: Defining a function to send Slack notifications about the deployment status.

29. `withCredentials([...]) { ... }`: Using the `withCredentials` block to securely access credentials (e.g., Slack token).

30. `slackSend(...)`: Sending Slack notifications with the specified message, channel, color, etc.

31. `def getBranchName(model, version) { ... }`: Defining a function to generate branch names based on the model and version.

This script automates the deployment of models stored in the `models` directory, with options to deploy specific models or versions based on user-defined parameters. It also sends notifications to developers via email and Slack about the deployment 


Certainly! The "Deploy Models" stage is responsible for deploying the models specified in the configuration. Let's break down the logic in detail:

1. **Initialization**: 
   - `def deployStages = [:]`: Initialize an empty map called `deployStages` to store deployment stages for each model.

2. **Model Iteration**:
   - `models.each { model -> ... }`: Iterate over each model found in the `models` directory.

3. **Deployment Stage Creation**:
   - `deployStages["Deploy ${model.name}"] = { ... }`: Add a deployment stage for the current model to the `deployStages` map.
   - This line creates a stage named "Deploy [ModelName]" where `[ModelName]` is the name of the current model.

4. **Version Iteration**:
   - `model.config.versions.each { version -> ... }`: Iterate over each version of the current model.

5. **Version Deployment Stage Creation**:
   - `versionStages["${model.name} - Version ${version.version}"] = { ... }`: Add a deployment stage for the current version to the `versionStages` map.
   - This line creates a stage named "[ModelName] - Version [Version]" where `[ModelName]` is the name of the current model and `[Version]` is the version being deployed.

6. **Parallel Execution**:
   - `parallel versionStages`: Run all version deployment stages in parallel.
   - This line ensures that all versions of the current model are deployed concurrently.

7. **Parallel Deployment Stages**:
   - `parallel deployStages`: Run all model deployment stages in parallel.
   - This line ensures that deployment stages for all models are executed concurrently.

The logic ensures efficient deployment by parallelizing the deployment of versions within each model and running the deployment of multiple models concurrently. This approach optimizes the deployment process, reducing the overall execution time.


Certainly! Here is a more detailed explanation of the rest of the Groovy script used in Jenkins for deploying models:

### Deployment Stage

```groovy
stage("Deploy Models") {
    def deployStages = [:]
```
- **Purpose**: This stage is designed for deploying models. A Groovy map (`deployStages`) is initialized to store different deployment tasks.

```groovy
    models.each { model ->
```
- **Purpose**: Iterates over each model added to the `models` list.

```groovy
        deployStages["Deploy ${model.name}"] = {
            def versionStages = [:]
```
- **Purpose**: Creates a key in the `deployStages` map with a dynamic key name for each model. Another map `versionStages` is created to handle different versions of the model to deploy.

```groovy
            model.config.versions.each { version ->
```
- **Purpose**: Iterates over each version available in the model's configuration.

```groovy
                if (params.Version == "All" || params.Version == version.version) {
```
- **Purpose**: Checks if all versions are to be deployed or only the specified version.

```groovy
                    versionStages["${model.name} - Version ${version.version}"] = {
                        def branch = getBranchName(model.name, version.version)
                        def job = DEPLOY_FOLDER_PATH + model.config.deploy_pipeline + "/" + branch
```
- **Purpose**: Dynamically names the version deployment task and calculates the branch name and job path for deployment.

```groovy
                        println("Job: " + job)
                        try {
                            build job: job
                        } catch(Exception e) {
                            failed.add(job)
                        }
                    }
```
- **Purpose**: Prints the job path for debugging, attempts to build/deploy the job using the calculated path, and catches any exceptions to log failed deployments.

```groovy
                }
            }
            parallel versionStages  // Run all version deployments in parallel
        }
    }
    parallel deployStages  // Run all model deployments in parallel
}
```
- **Purpose**: Executes all version deployments and then all model deployments in parallel, making the deployment process efficient.

### Alerting Stage

```groovy
stage("Alert devs of available PRs") {
```
- **Purpose**: This stage is designed to alert developers through email and Slack once the deployment is complete or if any deployment fails.

```groovy
    emailext(
        mimeType: 'text/html',
        subject: "Master Deploy pipeline complete.",
        to: "teamcore@nisone.com",
        body: "<p>The master deploy pipeline has completed. Models are now using the latest golden image.</p><p>The following models failed to deploy properly: ${failed}</p>"
    )
```
- **Purpose**: Sends an email to a specific team, informing them about the deployment status and any failures.

```groovy
    send_slack(failed)
}
```
- **Purpose**: Calls the `send_slack` function, passing the list of failed jobs to notify the team via Slack.

### Slack Notification Function

```groovy
def send_slack(failed) {
    withCredentials([string(credentialsId: "slack_token", variable: "token")]) {
        if (failed.isEmpty()) {
            slackSend(
                message: "The master deploy pipeline has completed.\nModels are now using the latest golden image.",
                channel: "teamcore",
                color: "#Dea218",
                teamDomain: "fstech-nisone",
                token: token
            )
        } else {
            slackSend(
                message: "The master deploy pipeline has completed. \nModels are now using the latest golden image.\nThe following models failed to deploy properly: \n${failed}",
                channel: "teamcore",
                color: "#ff9494",
                teamDomain: "fstech-nisone",
                token: token
            )
        }
    }
}
```
- **Purpose**: Sends a Slack notification using secured credentials for the Slack token. It notifies whether the deployment was successful or if there were any failures.

This Groovy script is structured to handle deployment processes in a Jenkins environment, leveraging parallel execution for efficiency and providing notifications for status updates. Each function and line has a specific purpose, from setup to execution and notification, ensuring a comprehensive automated deployment process.







